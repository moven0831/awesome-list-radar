import * as core from "@actions/core";
import * as github from "@actions/github";
import type { RadarConfig } from "../config.js";
import type { ClassifiedCandidate } from "../sources/types.js";

function escapeTableCell(value: string): string {
  return value.replace(/\|/g, "\\|").replace(/\n/g, " ");
}

function buildIssueTitle(candidate: ClassifiedCandidate): string {
  return `[Radar] ${escapeTableCell(candidate.title).slice(0, 200)}`;
}

function buildIssueBody(candidate: ClassifiedCandidate): string {
  const lines = [
    `## Candidate Resource`,
    ``,
    `| Field | Value |`,
    `|-------|-------|`,
    `| **URL** | ${escapeTableCell(candidate.url)} |`,
    `| **Source** | ${escapeTableCell(candidate.source)} |`,
    `| **Relevance Score** | ${candidate.relevanceScore}/100 |`,
    `| **Suggested Category** | ${escapeTableCell(candidate.suggestedCategory)} |`,
  ];

  if (candidate.suggestedTags.length > 0) {
    lines.push(
      `| **Tags** | ${candidate.suggestedTags.map((t) => `\`${escapeTableCell(t)}\``).join(", ")} |`
    );
  }

  if (candidate.metadata.stars !== undefined) {
    lines.push(`| **Stars** | ${candidate.metadata.stars} |`);
  }

  if (candidate.metadata.language) {
    lines.push(
      `| **Language** | ${escapeTableCell(candidate.metadata.language)} |`
    );
  }

  if (candidate.metadata.authors?.length) {
    lines.push(
      `| **Authors** | ${escapeTableCell(candidate.metadata.authors.join(", "))} |`
    );
  }

  lines.push(
    ``,
    `## Description`,
    ``,
    "```",
    (candidate.description || "No description available").slice(0, 1000),
    "```",
    ``,
    `## LLM Reasoning`,
    ``,
    "```",
    (candidate.reasoning || "No reasoning provided").slice(0, 500),
    "```",
    ``,
    `## Suggested Entry`,
    ``,
    `\`\`\`markdown`,
    `- [${candidate.title}](${candidate.url}) - ${candidate.description.slice(0, 100)}`,
    `\`\`\``,
    ``,
    `---`,
    `*Generated by [awesome-list-radar](https://github.com/moven0831/awesome-list-radar)*`
  );

  return lines.join("\n");
}

export interface IssueClient {
  listIssues(labels: string[]): Promise<{ title: string; body?: string }[]>;
  createIssue(
    title: string,
    body: string,
    labels: string[]
  ): Promise<{ number: number; html_url: string }>;
}

function makeGitHubClient(token: string): IssueClient {
  const octokit = github.getOctokit(token);
  const { owner, repo } = github.context.repo;

  return {
    async listIssues(labels: string[]) {
      // Note: fetches up to 100 open issues. Repos with >100 open radar
      // issues may see duplicate issue creation. Use GitHub search API
      // for more robust dedup if this becomes an issue.
      const { data } = await octokit.rest.issues.listForRepo({
        owner,
        repo,
        state: "open",
        labels: labels.join(","),
        per_page: 100,
      });
      return data.map((i) => ({
        title: i.title,
        body: i.body ?? undefined,
      }));
    },

    async createIssue(title: string, body: string, labels: string[]) {
      const { data } = await octokit.rest.issues.create({
        owner,
        repo,
        title,
        body,
        labels,
      });
      return { number: data.number, html_url: data.html_url };
    },
  };
}

export async function createIssues(
  candidates: ClassifiedCandidate[],
  config: RadarConfig,
  dryRun: boolean,
  client?: IssueClient
): Promise<number> {
  if (candidates.length === 0) return 0;

  const labels = config.issue_template.labels;
  const issueClient =
    client ?? makeGitHubClient(core.getInput("github_token"));

  // Fetch existing issues for idempotency check
  let existingIssues: { title: string; body?: string }[] = [];
  try {
    existingIssues = await issueClient.listIssues(labels);
  } catch (error) {
    core.warning(
      `Could not fetch existing issues: ${error instanceof Error ? error.message : String(error)}`
    );
  }

  const existingUrls = new Set(
    existingIssues
      .map((issue) => {
        const match = issue.body?.match(
          /\| \*\*URL\*\* \| (https?:\/\/[^\s|]+)/
        );
        return match?.[1]?.toLowerCase();
      })
      .filter(Boolean)
  );

  let created = 0;

  for (const candidate of candidates) {
    if (existingUrls.has(candidate.url.toLowerCase())) {
      core.info(
        `Skipping "${candidate.title}" â€” issue already exists for ${candidate.url}`
      );
      continue;
    }

    const title = buildIssueTitle(candidate);
    const body = buildIssueBody(candidate);

    if (dryRun) {
      core.info(`[DRY RUN] Would create issue: ${title}`);
      core.info(`  URL: ${candidate.url}`);
      core.info(`  Score: ${candidate.relevanceScore}`);
      created++;
      continue;
    }

    try {
      const issue = await issueClient.createIssue(title, body, labels);
      core.info(`Created issue #${issue.number}: ${issue.html_url}`);
      created++;
    } catch (error) {
      core.warning(
        `Failed to create issue for "${candidate.title}": ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  return created;
}

export { buildIssueTitle, buildIssueBody, escapeTableCell };
